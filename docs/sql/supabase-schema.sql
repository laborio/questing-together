-- Questing Together (Pivot Loop + Roles + Actions) - Supabase schema bootstrap
-- Run this in Supabase SQL Editor for a fresh project.

begin;

create extension if not exists pgcrypto;

-- ----------------------------
-- Enum types
-- ----------------------------
do $$
begin
  if not exists (select 1 from pg_type where typname = 'player_id') then
    create type public.player_id as enum ('p1', 'p2', 'p3');
  end if;

  if not exists (select 1 from pg_type where typname = 'role_id') then
    create type public.role_id as enum ('sage', 'warrior', 'ranger');
  end if;

  if not exists (select 1 from pg_type where typname = 'room_status') then
    create type public.room_status as enum ('lobby', 'in_progress', 'finished');
  end if;

  if not exists (select 1 from pg_type where typname = 'room_message_kind') then
    create type public.room_message_kind as enum ('player', 'separator', 'system');
  end if;
end
$$;

-- ----------------------------
-- Helpers
-- ----------------------------
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create or replace function public.generate_room_code(p_length int default 6)
returns text
language plpgsql
as $$
declare
  chars text := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  out_code text := '';
  idx int;
begin
  if p_length < 4 then
    raise exception 'Room code length must be >= 4';
  end if;

  for idx in 1..p_length loop
    out_code := out_code || substr(chars, 1 + floor(random() * length(chars))::int, 1);
  end loop;

  return out_code;
end;
$$;

-- ----------------------------
-- Tables
-- ----------------------------
create table if not exists public.rooms (
  id uuid primary key default gen_random_uuid(),
  code text not null unique,
  host_user_id uuid not null references auth.users(id) on delete restrict,
  status public.room_status not null default 'lobby',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint rooms_code_format check (code = upper(code) and code ~ '^[A-Z0-9]{6,8}$')
);

create table if not exists public.room_players (
  id uuid primary key default gen_random_uuid(),
  room_id uuid not null references public.rooms(id) on delete cascade,
  player_id public.player_id not null,
  user_id uuid not null references auth.users(id) on delete cascade,
  role_id public.role_id,
  display_name text,
  is_connected boolean not null default true,
  joined_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (room_id, player_id),
  unique (room_id, user_id),
  unique (room_id, role_id)
);

alter table public.room_players add column if not exists display_name text;
alter table public.room_players drop constraint if exists room_players_display_name_format;
alter table public.room_players
  add constraint room_players_display_name_format
  check (display_name is null or display_name ~ '^[^\\s]+$');

create table if not exists public.room_messages (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.rooms(id) on delete cascade,
  scene_id text not null,
  kind public.room_message_kind not null default 'player',
  player_id public.player_id,
  text text not null check (length(trim(text)) > 0),
  created_at timestamptz not null default now(),
  constraint room_messages_kind_player_check check (
    (kind = 'player' and player_id is not null and scene_id is not null) or
    (kind <> 'player' and player_id is null)
  )
);

create table if not exists public.room_events (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.rooms(id) on delete cascade,
  actor_user_id uuid references auth.users(id) on delete set null,
  type text not null,
  payload_json jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

-- SECURITY DEFINER helper for policies.
create or replace function public.is_room_member(p_room_id uuid)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.room_players rp
    where rp.room_id = p_room_id
      and rp.user_id = auth.uid()
  );
$$;

grant execute on function public.is_room_member(uuid) to authenticated;

-- ----------------------------
-- Story helpers
-- ----------------------------
create or replace function public.story_next_scene_id(p_scene_id text)
returns text
language sql
immutable
as $$
  select case p_scene_id
    when 's1_courtyard_gate' then 's2_audience'
    when 's2_audience' then 's3_legendarium'
    when 's3_legendarium' then 's3_rest_wayhouse'
    when 's3_rest_wayhouse' then 's4_reliquary'
    when 's4_reliquary' then 's5_council'
    when 's5_council' then 'ending_reconciliation'
    else null
  end;
$$;

create or replace function public.story_last_reset_id(p_room_id uuid)
returns bigint
language sql
stable
security definer
set search_path = public
as $$
  select coalesce(max(re.id), 0)
  from public.room_events re
  where re.room_id = p_room_id
    and re.type = 'story_reset';
$$;

create or replace function public.story_current_scene_id(p_room_id uuid)
returns text
language plpgsql
stable
security definer
set search_path = public
as $$
declare
  v_current_scene_id text := 's1_courtyard_gate';
  v_start_scene_id text;
  v_next_scene_id text;
  v_reset_id bigint;
  rec record;
begin
  v_reset_id := public.story_last_reset_id(p_room_id);
  select re.payload_json->>'startSceneId'
  into v_start_scene_id
  from public.room_events re
  where re.room_id = p_room_id
    and re.type = 'story_reset'
  order by re.id desc
  limit 1;

  if v_start_scene_id is not null and v_start_scene_id <> '' then
    v_current_scene_id := v_start_scene_id;
  end if;

  for rec in
    select re.payload_json->>'sceneId' as scene_id,
           re.payload_json->>'nextSceneId' as next_scene_id
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > v_reset_id
      and re.type = 'scene_advance'
    order by re.id asc
  loop
    if rec.scene_id = v_current_scene_id then
      v_next_scene_id := rec.next_scene_id;
      if v_next_scene_id is null then
        v_next_scene_id := public.story_next_scene_id(v_current_scene_id);
      end if;
      if v_next_scene_id is not null then
        v_current_scene_id := v_next_scene_id;
      end if;
    end if;
  end loop;

  return v_current_scene_id;
end;
$$;

-- ----------------------------
-- Indexes
-- ----------------------------
create index if not exists idx_rooms_status on public.rooms(status);
create index if not exists idx_room_players_room on public.room_players(room_id);
create index if not exists idx_room_players_user on public.room_players(user_id);
create index if not exists idx_room_messages_room_created on public.room_messages(room_id, created_at desc);
create index if not exists idx_room_messages_room_scene_player_created
on public.room_messages(room_id, scene_id, player_id, created_at desc);
create index if not exists idx_room_events_room_created on public.room_events(room_id, created_at desc);

-- ----------------------------
-- Triggers
-- ----------------------------
drop trigger if exists trg_rooms_updated_at on public.rooms;
create trigger trg_rooms_updated_at
before update on public.rooms
for each row
execute function public.set_updated_at();

drop trigger if exists trg_room_players_updated_at on public.room_players;
create trigger trg_room_players_updated_at
before update on public.room_players
for each row
execute function public.set_updated_at();

-- ----------------------------
-- RPCs
-- ----------------------------
create or replace function public.create_room(p_player_id public.player_id default 'p1')
returns table(room_id uuid, room_code text)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_room_id uuid;
  v_code text;
  v_attempts int := 0;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  loop
    v_code := public.generate_room_code(6);
    exit when not exists (select 1 from public.rooms r where r.code = v_code);
    v_attempts := v_attempts + 1;
    if v_attempts > 20 then
      raise exception 'Could not generate a unique room code';
    end if;
  end loop;

  insert into public.rooms (code, host_user_id, status)
  values (v_code, v_user_id, 'lobby')
  returning id into v_room_id;

  insert into public.room_players (room_id, player_id, user_id)
  values (v_room_id, p_player_id, v_user_id);

  return query select v_room_id, v_code;
end;
$$;

create or replace function public.join_room(p_code text, p_player_id public.player_id)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_room_id uuid;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.id
  into v_room_id
  from public.rooms r
  where r.code = upper(trim(p_code))
    and r.status <> 'finished';

  if v_room_id is null then
    raise exception 'Room not found';
  end if;

  if exists (
    select 1 from public.room_players rp
    where rp.room_id = v_room_id
      and rp.user_id = v_user_id
  ) then
    return v_room_id;
  end if;

  if exists (
    select 1 from public.room_players rp
    where rp.room_id = v_room_id
      and rp.player_id = p_player_id
  ) then
    raise exception 'Player slot % is already taken in this room', p_player_id;
  end if;

  insert into public.room_players (room_id, player_id, user_id)
  values (v_room_id, p_player_id, v_user_id);

  return v_room_id;
end;
$$;

create or replace function public.leave_room(p_room_id uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_removed int;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  delete from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  get diagnostics v_removed = row_count;

  if v_removed > 0 then
    delete from public.rooms r
    where r.id = p_room_id
      and not exists (
        select 1 from public.room_players rp2 where rp2.room_id = r.id
      );
    return true;
  end if;

  return false;
end;
$$;

create or replace function public.send_room_message(
  p_room_id uuid,
  p_scene_id text,
  p_text text
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_reset_at timestamptz;
  v_message_count int;
  v_message_id bigint;
  v_trimmed_text text;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if not public.is_room_member(p_room_id) then
    raise exception 'Not a room member';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  v_trimmed_text := regexp_replace(trim(coalesce(p_text, '')), '\s+', ' ', 'g');
  if v_trimmed_text = '' then
    raise exception 'Message cannot be empty';
  end if;

  if char_length(v_trimmed_text) > 30 then
    raise exception 'Message exceeds 30 characters';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id is distinct from v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  select coalesce(max(re.created_at), '-infinity'::timestamptz)
  into v_reset_at
  from public.room_events re
  where re.room_id = p_room_id
    and re.type = 'story_reset';

  select count(*)
  into v_message_count
  from public.room_messages rm
  where rm.room_id = p_room_id
    and rm.scene_id = p_scene_id
    and rm.kind = 'player'
    and rm.player_id = v_player_id
    and rm.created_at > v_reset_at;

  if v_message_count >= 4 then
    raise exception 'Mind-bond message limit reached for this scene';
  end if;

  insert into public.room_messages (room_id, scene_id, kind, player_id, text)
  values (p_room_id, p_scene_id, 'player', v_player_id, v_trimmed_text)
  returning id into v_message_id;

  return v_message_id;
end;
$$;

create or replace function public.story_select_role(
  p_room_id uuid,
  p_role_id public.role_id
)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_room_status public.room_status;
  v_local_player_id public.player_id;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'lobby' then
    raise exception 'Role selection is only available in lobby';
  end if;

  select rp.player_id
  into v_local_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_local_player_id is null then
    raise exception 'Not a room member';
  end if;

  if exists (
    select 1
    from public.room_players rp
    where rp.room_id = p_room_id
      and rp.role_id = p_role_id
      and rp.user_id <> v_user_id
  ) then
    raise exception 'Role already taken';
  end if;

  update public.room_players rp
  set role_id = p_role_id
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  return true;
end;
$$;

create or replace function public.story_set_display_name(
  p_room_id uuid,
  p_display_name text
)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_room_status public.room_status;
  v_trimmed text;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if not public.is_room_member(p_room_id) then
    raise exception 'Not a room member';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  v_trimmed := trim(coalesce(p_display_name, ''));
  if v_trimmed = '' then
    raise exception 'Name cannot be empty';
  end if;
  if v_trimmed ~ '\\s' then
    raise exception 'Name cannot contain spaces';
  end if;
  if char_length(v_trimmed) > 20 then
    raise exception 'Name must be 20 characters or fewer';
  end if;

  update public.room_players
  set display_name = v_trimmed,
      updated_at = now()
  where room_id = p_room_id
    and user_id = v_user_id;

  return true;
end;
$$;

create or replace function public.story_start_adventure(
  p_room_id uuid,
  p_start_scene_id text default null
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_host_id uuid;
  v_room_status public.room_status;
  v_player_count int;
  v_assigned_count int;
  v_unique_roles int;
  v_event_id bigint;
  v_start_scene_id text := coalesce(nullif(p_start_scene_id, ''), 's1_courtyard_gate');
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.host_user_id, r.status
  into v_host_id, v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_host_id is null then
    raise exception 'Room not found';
  end if;

  if v_host_id <> v_user_id then
    raise exception 'Only host can start adventure';
  end if;

  if v_room_status <> 'lobby' then
    raise exception 'Adventure already started';
  end if;

  select count(*),
         count(*) filter (where rp.role_id is not null),
         count(distinct rp.role_id)
  into v_player_count, v_assigned_count, v_unique_roles
  from public.room_players rp
  where rp.room_id = p_room_id;

  if v_player_count <> 3 then
    raise exception 'Adventure requires exactly 3 players';
  end if;

  if v_assigned_count <> 3 or v_unique_roles <> 3 then
    raise exception 'All 3 roles must be uniquely assigned before start';
  end if;

  update public.rooms
  set status = 'in_progress'
  where id = p_room_id;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'story_reset',
    jsonb_build_object('startSceneId', v_start_scene_id)
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.story_take_action(
  p_room_id uuid,
  p_scene_id text,
  p_step_id text,
  p_action_id text
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_action_count int;
  v_event_id bigint;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  if p_action_id = 'no_reaction' then
    if not exists (
      select 1
      from public.room_events re
      where re.room_id = p_room_id
        and re.id > public.story_last_reset_id(p_room_id)
        and re.type = 'scene_action'
        and re.payload_json->>'sceneId' = p_scene_id
        and re.payload_json->>'stepId' = p_step_id
    ) then
      raise exception 'Cannot skip before any action is taken';
    end if;
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_action'
      and re.payload_json->>'sceneId' = p_scene_id
      and re.payload_json->>'stepId' = p_step_id
      and re.payload_json->>'playerId' = v_player_id::text
  ) then
    return null;
  end if;

  select count(distinct re.payload_json->>'playerId')
  into v_action_count
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_action'
    and re.payload_json->>'sceneId' = p_scene_id
    and re.payload_json->>'stepId' = p_step_id;

  if v_action_count >= 3 then
    raise exception 'Scene step already complete';
  end if;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'scene_action',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'stepId', p_step_id,
      'actionId', p_action_id,
      'playerId', v_player_id::text
    )
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.story_confirm_option(
  p_room_id uuid,
  p_scene_id text,
  p_step_id text,
  p_option_id text,
  p_next_scene_id text
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_confirm_event_id bigint;
  v_action_count int := 0;
  v_vote_count int := 0;
  v_top_count int := 0;
  v_tied_options text[];
  v_resolved_option text;
  v_resolved_next_scene_id text;
  v_resolution_mode text := 'majority';
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  if p_option_id not in ('A', 'B', 'C') then
    raise exception 'Invalid option';
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_resolve'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    return null;
  end if;

  select count(distinct re.payload_json->>'playerId')
  into v_action_count
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_action'
    and re.payload_json->>'sceneId' = p_scene_id
    and re.payload_json->>'stepId' = p_step_id;

  if v_action_count < 3 then
    raise exception 'Waiting for all reactions before voting';
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'option_confirm'
      and re.payload_json->>'sceneId' = p_scene_id
      and re.payload_json->>'playerId' = v_player_id::text
  ) then
    return null;
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'option_confirm'
      and re.payload_json->>'sceneId' = p_scene_id
      and re.payload_json->>'optionId' = p_option_id
      and coalesce(re.payload_json->>'nextSceneId', '') <> coalesce(p_next_scene_id, '')
  ) then
    raise exception 'Mismatched next scene for option';
  end if;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'option_confirm',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'optionId', p_option_id,
      'playerId', v_player_id::text,
      'nextSceneId', p_next_scene_id
    )
  )
  returning id into v_confirm_event_id;

  select count(*)
  into v_vote_count
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'option_confirm'
    and re.payload_json->>'sceneId' = p_scene_id;

  if v_vote_count = 3 and not exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_resolve'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    with option_counts as (
      select re.payload_json->>'optionId' as option_id, count(*) as vote_count
      from public.room_events re
      where re.room_id = p_room_id
        and re.id > public.story_last_reset_id(p_room_id)
        and re.type = 'option_confirm'
        and re.payload_json->>'sceneId' = p_scene_id
      group by re.payload_json->>'optionId'
    )
    select max(oc.vote_count) into v_top_count from option_counts oc;

    with option_counts as (
      select re.payload_json->>'optionId' as option_id, count(*) as vote_count
      from public.room_events re
      where re.room_id = p_room_id
        and re.id > public.story_last_reset_id(p_room_id)
        and re.type = 'option_confirm'
        and re.payload_json->>'sceneId' = p_scene_id
      group by re.payload_json->>'optionId'
    )
    select array_agg(oc.option_id order by oc.option_id) into v_tied_options
    from option_counts oc
    where oc.vote_count = v_top_count;

    if coalesce(array_length(v_tied_options, 1), 0) = 0 then
      raise exception 'Could not resolve votes';
    elsif array_length(v_tied_options, 1) = 1 then
      v_resolved_option := v_tied_options[1];
      v_resolution_mode := 'majority';
    else
      v_resolved_option := v_tied_options[1 + floor(random() * array_length(v_tied_options, 1))::int];
      v_resolution_mode := 'random';
    end if;

    select re.payload_json->>'nextSceneId'
    into v_resolved_next_scene_id
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'option_confirm'
      and re.payload_json->>'sceneId' = p_scene_id
      and re.payload_json->>'optionId' = v_resolved_option
    order by re.id desc
    limit 1;

    insert into public.room_events (room_id, actor_user_id, type, payload_json)
    values (
      p_room_id,
      v_user_id,
      'scene_resolve',
      jsonb_build_object(
        'sceneId', p_scene_id,
        'optionId', v_resolved_option,
        'mode', v_resolution_mode,
        'nextSceneId', v_resolved_next_scene_id
      )
    );
  end if;

  return v_confirm_event_id;
end;
$$;

create or replace function public.story_resolve_combat(
  p_room_id uuid,
  p_scene_id text,
  p_option_id text,
  p_next_scene_id text
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_event_id bigint;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_resolve'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    return null;
  end if;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'scene_resolve',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'optionId', p_option_id,
      'mode', 'combat',
      'nextSceneId', p_next_scene_id
    )
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.story_start_timer(
  p_room_id uuid,
  p_scene_id text,
  p_step_id text,
  p_duration_seconds int
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_action_count int := 0;
  v_event_id bigint;
  v_end_at timestamptz;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  if p_duration_seconds is null or p_duration_seconds <= 0 then
    raise exception 'Invalid timer duration';
  end if;

  select count(distinct re.payload_json->>'playerId')
  into v_action_count
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_action'
    and re.payload_json->>'sceneId' = p_scene_id
    and re.payload_json->>'stepId' = p_step_id;

  if v_action_count < 3 then
    raise exception 'Waiting for all reactions before starting timer';
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_timer_started'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    return null;
  end if;

  v_end_at := now() + make_interval(secs => p_duration_seconds);

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'scene_timer_started',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'stepId', p_step_id,
      'endAt', v_end_at,
      'durationSeconds', p_duration_seconds
    )
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.story_resolve_timed_scene(
  p_room_id uuid,
  p_scene_id text,
  p_option_id text,
  p_next_scene_id text,
  p_force boolean
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_event_id bigint;
  v_end_at timestamptz;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status
  into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id
  into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  if exists (
    select 1
    from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_advance'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    return null;
  end if;

  select (re.payload_json->>'endAt')::timestamptz
  into v_end_at
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_timer_started'
    and re.payload_json->>'sceneId' = p_scene_id
  order by re.id desc
  limit 1;

  if v_end_at is null then
    raise exception 'Timer not started';
  end if;

  if now() < v_end_at and not coalesce(p_force, false) then
    raise exception 'Timer not complete';
  end if;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'scene_advance',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'optionId', p_option_id,
      'nextSceneId', p_next_scene_id
    )
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

create or replace function public.story_continue_scene(
  p_room_id uuid,
  p_scene_id text
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_player_id public.player_id;
  v_room_status public.room_status;
  v_current_scene_id text;
  v_continue_event_id bigint;
  v_continue_count int := 0;
  v_resolved_option text;
  v_next_scene_id text;
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  select r.status into v_room_status
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_room_status is null then
    raise exception 'Room not found';
  end if;

  if v_room_status <> 'in_progress' then
    raise exception 'Adventure not started';
  end if;

  select rp.player_id into v_player_id
  from public.room_players rp
  where rp.room_id = p_room_id
    and rp.user_id = v_user_id;

  if v_player_id is null then
    raise exception 'Not a room member';
  end if;

  v_current_scene_id := public.story_current_scene_id(p_room_id);
  if p_scene_id <> v_current_scene_id then
    raise exception 'Scene is no longer active';
  end if;

  select re.payload_json->>'optionId'
  into v_resolved_option
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_resolve'
    and re.payload_json->>'sceneId' = p_scene_id
  order by re.id desc
  limit 1;

  if v_resolved_option is null then
    raise exception 'Scene vote is not resolved yet';
  end if;

  select re.payload_json->>'nextSceneId'
  into v_next_scene_id
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_resolve'
    and re.payload_json->>'sceneId' = p_scene_id
  order by re.id desc
  limit 1;

  if exists (
    select 1 from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_continue'
      and re.payload_json->>'sceneId' = p_scene_id
      and re.payload_json->>'playerId' = v_player_id::text
  ) then
    return null;
  end if;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'scene_continue',
    jsonb_build_object(
      'sceneId', p_scene_id,
      'playerId', v_player_id::text
    )
  )
  returning id into v_continue_event_id;

  select count(distinct re.payload_json->>'playerId')
  into v_continue_count
  from public.room_events re
  where re.room_id = p_room_id
    and re.id > public.story_last_reset_id(p_room_id)
    and re.type = 'scene_continue'
    and re.payload_json->>'sceneId' = p_scene_id;

  if v_next_scene_id is null then
    return v_continue_event_id;
  end if;

  if v_continue_count = 3 and not exists (
    select 1 from public.room_events re
    where re.room_id = p_room_id
      and re.id > public.story_last_reset_id(p_room_id)
      and re.type = 'scene_advance'
      and re.payload_json->>'sceneId' = p_scene_id
  ) then
    insert into public.room_events (room_id, actor_user_id, type, payload_json)
    values (
      p_room_id,
      v_user_id,
      'scene_advance',
      jsonb_build_object(
        'sceneId', p_scene_id,
        'optionId', v_resolved_option,
        'nextSceneId', v_next_scene_id
      )
    );
  end if;

  return v_continue_event_id;
end;
$$;

create or replace function public.story_reset(
  p_room_id uuid,
  p_start_scene_id text default null
)
returns bigint
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id uuid := auth.uid();
  v_host_id uuid;
  v_event_id bigint;
  v_start_scene_id text := coalesce(nullif(p_start_scene_id, ''), 's1_courtyard_gate');
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if not public.is_room_member(p_room_id) then
    raise exception 'Not a room member';
  end if;

  select r.host_user_id
  into v_host_id
  from public.rooms r
  where r.id = p_room_id
  for update;

  if v_host_id is null then
    raise exception 'Room not found';
  end if;

  if v_host_id <> v_user_id then
    raise exception 'Only host can reset story';
  end if;

  update public.rooms
  set status = 'in_progress'
  where id = p_room_id;

  insert into public.room_events (room_id, actor_user_id, type, payload_json)
  values (
    p_room_id,
    v_user_id,
    'story_reset',
    jsonb_build_object('startSceneId', v_start_scene_id)
  )
  returning id into v_event_id;

  return v_event_id;
end;
$$;

grant execute on function public.create_room(public.player_id) to authenticated;
grant execute on function public.join_room(text, public.player_id) to authenticated;
grant execute on function public.leave_room(uuid) to authenticated;
grant execute on function public.send_room_message(uuid, text, text) to authenticated;
grant execute on function public.story_select_role(uuid, public.role_id) to authenticated;
grant execute on function public.story_set_display_name(uuid, text) to authenticated;
grant execute on function public.story_start_adventure(uuid, text) to authenticated;
grant execute on function public.story_take_action(uuid, text, text, text) to authenticated;
grant execute on function public.story_confirm_option(uuid, text, text, text, text) to authenticated;
grant execute on function public.story_resolve_combat(uuid, text, text, text) to authenticated;
grant execute on function public.story_start_timer(uuid, text, text, int) to authenticated;
grant execute on function public.story_resolve_timed_scene(uuid, text, text, text, boolean) to authenticated;
grant execute on function public.story_continue_scene(uuid, text) to authenticated;
grant execute on function public.story_reset(uuid, text) to authenticated;

-- ----------------------------
-- Realtime publication
-- ----------------------------
do $$
begin
  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'rooms'
  ) then
    execute 'alter publication supabase_realtime add table public.rooms';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'room_players'
  ) then
    execute 'alter publication supabase_realtime add table public.room_players';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'room_messages'
  ) then
    execute 'alter publication supabase_realtime add table public.room_messages';
  end if;

  if not exists (
    select 1 from pg_publication_tables
    where pubname = 'supabase_realtime'
      and schemaname = 'public'
      and tablename = 'room_events'
  ) then
    execute 'alter publication supabase_realtime add table public.room_events';
  end if;
end
$$;

-- ----------------------------
-- Row Level Security
-- ----------------------------
alter table public.rooms enable row level security;
alter table public.room_players enable row level security;
alter table public.room_messages enable row level security;
alter table public.room_events enable row level security;

drop policy if exists rooms_select_member on public.rooms;
create policy rooms_select_member
on public.rooms
for select
to authenticated
using (public.is_room_member(id));

drop policy if exists rooms_update_host on public.rooms;
create policy rooms_update_host
on public.rooms
for update
to authenticated
using (host_user_id = auth.uid())
with check (host_user_id = auth.uid());

drop policy if exists rooms_delete_host on public.rooms;
create policy rooms_delete_host
on public.rooms
for delete
to authenticated
using (host_user_id = auth.uid());

drop policy if exists room_players_select_member on public.room_players;
create policy room_players_select_member
on public.room_players
for select
to authenticated
using (public.is_room_member(room_id));

drop policy if exists room_players_update_self on public.room_players;
create policy room_players_update_self
on public.room_players
for update
to authenticated
using (user_id = auth.uid())
with check (user_id = auth.uid());

drop policy if exists room_players_delete_self on public.room_players;
create policy room_players_delete_self
on public.room_players
for delete
to authenticated
using (user_id = auth.uid());

drop policy if exists room_messages_select_member on public.room_messages;
create policy room_messages_select_member
on public.room_messages
for select
to authenticated
using (public.is_room_member(room_id));

drop policy if exists room_messages_insert_self_player on public.room_messages;

drop policy if exists room_events_select_member on public.room_events;
create policy room_events_select_member
on public.room_events
for select
to authenticated
using (public.is_room_member(room_id));

drop policy if exists room_events_insert_member on public.room_events;

-- ----------------------------
-- Privileges
-- ----------------------------
grant select, update, delete on public.rooms to authenticated;
grant select, delete on public.room_players to authenticated;
grant select on public.room_messages to authenticated;
revoke insert on public.room_messages from authenticated;
grant select on public.room_events to authenticated;
revoke insert on public.room_events from authenticated;
grant usage, select on all sequences in schema public to authenticated;

commit;
